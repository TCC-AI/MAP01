<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å°ç£è·¯ç·šåœ°åœ–</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    
    <style>
        /* ===== CSS æ¨£å¼ ===== */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Microsoft JhengHei', Arial, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        header {
            background: rgba(255, 255, 255, 0.95);
            padding: 20px;
            border-radius: 15px;
            margin-bottom: 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            display: flex;
            justify-content: space-between;
            align-items: center;
            backdrop-filter: blur(10px);
        }

        h1 {
            color: #333;
            font-size: 2rem;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.1);
        }

        .controls {
            display: flex;
            gap: 10px;
        }

        button {
            background: linear-gradient(45deg, #4CAF50, #45a049);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(76, 175, 80, 0.3);
        }

        button:hover {
            background: linear-gradient(45deg, #45a049, #4CAF50);
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(76, 175, 80, 0.4);
        }

        button:active {
            transform: translateY(0);
        }

        .map-container {
            position: relative;
            background: white;
            border-radius: 15px;
            overflow: hidden;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
        }

        #map {
            height: 600px;
            width: 100%;
        }

        .legend {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.95);
            padding: 15px;
            border-radius: 10px;
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.1);
            max-width: 300px;
            max-height: 400px;
            overflow-y: auto;
            z-index: 1000;
            backdrop-filter: blur(10px);
        }

        .legend h3 {
            margin-bottom: 15px;
            color: #333;
            font-size: 1.2rem;
            border-bottom: 2px solid #4CAF50;
            padding-bottom: 5px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
            padding: 5px;
            border-radius: 5px;
            transition: background 0.2s ease;
        }

        .legend-item:hover {
            background: rgba(76, 175, 80, 0.1);
        }

        .legend-color {
            width: 20px;
            height: 4px;
            margin-right: 10px;
            border-radius: 2px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.2);
        }

        .legend-text {
            font-size: 12px;
            color: #555;
            line-height: 1.3;
        }

        .loading {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            color: white;
        }

        .spinner {
            width: 60px;
            height: 60px;
            border: 6px solid #f3f3f3;
            border-top: 6px solid #4CAF50;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .loading p {
            font-size: 1.2rem;
            margin-top: 10px;
        }

        .error {
            background: linear-gradient(45deg, #f44336, #d32f2f);
            color: white;
            padding: 20px;
            border-radius: 10px;
            margin-top: 20px;
            text-align: center;
            box-shadow: 0 4px 15px rgba(244, 67, 54, 0.3);
        }

        .error h3 {
            margin-bottom: 10px;
            font-size: 1.3rem;
        }

        .hidden {
            display: none !important;
        }

        .route-popup {
            min-width: 200px;
        }

        .route-popup h4 {
            color: #4CAF50;
            margin-bottom: 10px;
            font-size: 1.1rem;
        }

        .route-popup p {
            margin-bottom: 5px;
            font-size: 0.9rem;
        }

        .custom-marker {
            border: none !important;
            background: transparent !important;
        }

        .status-bar {
            background: rgba(255, 255, 255, 0.9);
            padding: 10px 20px;
            border-radius: 10px;
            margin-top: 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.9rem;
            color: #666;
        }

        .status-indicator {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #4CAF50;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }

        /* éŸ¿æ‡‰å¼è¨­è¨ˆ */
        @media (max-width: 768px) {
            .container {
                padding: 10px;
            }
            
            header {
                flex-direction: column;
                gap: 15px;
                padding: 15px;
            }
            
            h1 {
                font-size: 1.5rem;
            }
            
            #map {
                height: 400px;
            }
            
            .legend {
                position: relative;
                top: auto;
                right: auto;
                margin: 20px;
                max-width: none;
            }
            
            .controls {
                flex-wrap: wrap;
                justify-content: center;
            }
            
            button {
                padding: 10px 20px;
                font-size: 13px;
            }
            
            .status-bar {
                flex-direction: column;
                gap: 10px;
                text-align: center;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>ğŸ—ºï¸ å°ç£è·¯ç·šè¿½è¹¤åœ°åœ–</h1>
            <div class="controls">
                <button id="refreshBtn">ğŸ”„ é‡æ–°è¼‰å…¥</button>
                <button id="toggleLegend">ğŸ“‹ åœ–ä¾‹</button>
                <button id="clearCache">ğŸ—‘ï¸ æ¸…é™¤å¿«å–</button>
            </div>
        </header>
        
        <div class="map-container">
            <div id="map"></div>
            <div id="legend" class="legend hidden">
                <h3>ğŸ“ è·¯ç·šåœ–ä¾‹</h3>
                <div id="legendContent"></div>
            </div>
        </div>
        
        <div class="status-bar">
            <div class="status-indicator">
                <div class="status-dot"></div>
                <span id="statusText">ç³»çµ±å°±ç·’</span>
            </div>
            <div>
                <span>æœ€å¾Œæ›´æ–°: </span>
                <span id="lastUpdate">å°šæœªè¼‰å…¥</span>
            </div>
            <div>
                <span>è·¯ç·šæ•¸é‡: </span>
                <span id="routeCount">0</span>
            </div>
        </div>
        
        <div id="loading" class="loading hidden">
            <div class="spinner"></div>
            <p>ğŸ”„ è¼‰å…¥è·¯ç·šè³‡æ–™ä¸­...</p>
            <small>è«‹ç¨å€™ï¼Œæ­£åœ¨å¾ Google Sheets ç²å–æœ€æ–°è³‡æ–™</small>
        </div>
        
        <div id="error" class="error hidden">
            <h3>âŒ è¼‰å…¥å¤±æ•—</h3>
            <p id="errorMessage">ç„¡æ³•è¼‰å…¥è·¯ç·šè³‡æ–™ï¼Œè«‹ç¨å¾Œå†è©¦</p>
            <button onclick="window.taiwanMap.loadRoutes()" style="margin-top: 10px;">
                ğŸ”„ é‡æ–°å˜—è©¦
            </button>
        </div>
    </div>
    
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    
    <script>
        /* ===== JavaScript ä»£ç¢¼ ===== */
        
        // é…ç½®è¨­å®š
        const CONFIG = {
            // Google Sheets è¨­å®š
            SHEET_ID: '15Uz4_XE9jf2k2phkuIeodnatpPlK04FHOe0mTHwimT0',
            SHEET_RANGE: 'å·¥ä½œè¡¨1!A:E',
            
            // å¾Œç«¯ API è¨­å®š (è«‹æ›¿æ›ç‚ºæ‚¨çš„å¾Œç«¯ç¶²å€)
            API_BASE_URL: 'https://script.google.com/macros/s/AKfycbzdJVd8JhRVJQwPmGAKUpxDz_p9UZNQmdfhmpdXA8la7C6xTh5rOFJsCRwbwhHdvJdF/exec',
            
            // åœ°åœ–è¨­å®š
            MAP_CENTER: [23.8, 121.0],
            MAP_ZOOM: 7,
            
            // è·¯ç·šé¡è‰²
            ROUTE_COLORS: [
                '#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4', 
                '#FFEAA7', '#DDA0DD', '#98D8C8', '#F7DC6F',
                '#BB8FCE', '#85C1E9', '#F8C471', '#82E0AA',
                '#F1948A', '#85C1E9', '#F8C471', '#82E0AA'
            ],
            
            // æ›´æ–°é–“éš” (æ¯«ç§’)
            REFRESH_INTERVAL: 300000 // 5åˆ†é˜
        };

        // å°ç£ä¸»è¦åœ°é»åº§æ¨™
        const TAIWAN_LOCATIONS = {
            'å°åŒ—': [25.0330, 121.5654],
            'æ–°åŒ—': [25.0173, 121.4467],
            'æ¡ƒåœ’': [24.9936, 121.3010],
            'æ–°ç«¹': [24.8138, 120.9675],
            'è‹—æ —': [24.5602, 120.8214],
            'å°ä¸­': [24.1477, 120.6736],
            'å½°åŒ–': [24.0518, 120.5161],
            'å—æŠ•': [23.9609, 120.9718],
            'é›²æ—': [23.7092, 120.4313],
            'å˜‰ç¾©': [23.4801, 120.4491],
            'å°å—': [22.9999, 120.2269],
            'é«˜é›„': [22.6273, 120.3014],
            'å±æ±': [22.5519, 120.5487],
            'å®œè˜­': [24.7021, 121.7378],
            'èŠ±è“®': [23.9871, 121.6015],
            'å°æ±': [22.7972, 121.1713],
            'æ¾æ¹–': [23.5711, 119.5793],
            'é‡‘é–€': [24.4492, 118.3765],
            'é€£æ±Ÿ': [26.1605, 119.9297],
            // æ–°å¢æ›´å¤šåœ°é»
            'åŸºéš†': [25.1276, 121.7391],
            'ç«¹åŒ—': [24.8387, 121.0177],
            'é ­ä»½': [24.6958, 120.8967],
            'è±åŸ': [24.2567, 120.7235],
            'å“¡æ—': [23.9588, 120.5667],
            'æ–—å…­': [23.7117, 120.5444],
            'æœ´å­': [23.4647, 120.2474],
            'æ–°ç‡Ÿ': [23.3059, 120.3175],
            'é³³å±±': [22.6268, 120.3565],
            'æ½®å·': [22.5503, 120.5619]
        };

        // ä¸»è¦åœ°åœ–é¡åˆ¥
        class TaiwanRouteMap {
            constructor() {
                this.map = null;
                this.routeLayers = [];
                this.routeData = [];
                this.autoRefreshTimer = null;
                this.init();
            }

            // åˆå§‹åŒ–åœ°åœ–
            init() {
                this.initMap();
                this.bindEvents();
                this.loadRoutes();
                this.startAutoRefresh();
                this.updateStatus('ç³»çµ±åˆå§‹åŒ–å®Œæˆ');
            }

            // å»ºç«‹åœ°åœ–
            initMap() {
                this.map = L.map('map').setView(CONFIG.MAP_CENTER, CONFIG.MAP_ZOOM);
                
                // æ·»åŠ åœ°åœ–åœ–å±¤
                L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                    attribution: 'Â© OpenStreetMap contributors | å°ç£è·¯ç·šè¿½è¹¤ç³»çµ±',
                    maxZoom: 18
                }).addTo(this.map);

                // æ·»åŠ æ¯”ä¾‹å°º
                L.control.scale({
                    position: 'bottomleft',
                    metric: true,
                    imperial: false
                }).addTo(this.map);

                this.updateStatus('åœ°åœ–åˆå§‹åŒ–å®Œæˆ');
            }

            // ç¶å®šäº‹ä»¶
            bindEvents() {
                // é‡æ–°è¼‰å…¥æŒ‰éˆ•
                document.getElementById('refreshBtn').addEventListener('click', () => {
                    this.loadRoutes();
                });

                // åœ–ä¾‹åˆ‡æ›æŒ‰éˆ•
                document.getElementById('toggleLegend').addEventListener('click', () => {
                    const legend = document.getElementById('legend');
                    legend.classList.toggle('hidden');
                });

                // æ¸…é™¤å¿«å–æŒ‰éˆ•
                document.getElementById('clearCache').addEventListener('click', () => {
                    this.clearLocalCache();
                });

                // åœ°åœ–é»æ“Šäº‹ä»¶
                this.map.on('click', (e) => {
                    console.log('é»æ“Šåº§æ¨™:', e.latlng);
                });
            }

            // è¼‰å…¥è·¯ç·šè³‡æ–™
            async loadRoutes() {
                this.showLoading(true);
                this.hideError();
                this.updateStatus('æ­£åœ¨è¼‰å…¥è·¯ç·šè³‡æ–™...');

                try {
                    // å…ˆå˜—è©¦å¾æœ¬åœ°å¿«å–è¼‰å…¥
                    const cachedData = this.getLocalCache();
                    if (cachedData && this.isCacheValid(cachedData.timestamp)) {
                        console.log('ä½¿ç”¨æœ¬åœ°å¿«å–è³‡æ–™');
                        this.processRouteData(cachedData.routes, true);
                        return;
                    }

                    // å¾å¾Œç«¯ API è¼‰å…¥
                    const response = await fetch(`${CONFIG.API_BASE_URL}/api/routes`, {
                        method: 'GET',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        timeout: 10000
                    });
                    
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    
                    const data = await response.json();
                    
                    if (data.success) {
                        this.processRouteData(data.routes, data.cached);
                        this.saveLocalCache(data.routes);
                        this.updateStatus('è³‡æ–™è¼‰å…¥æˆåŠŸ');
                    } else {
                        throw new Error(data.message || 'è¼‰å…¥å¤±æ•—');
                    }
                    
                } catch (error) {
                    console.error('è¼‰å…¥è·¯ç·šå¤±æ•—:', error);
                    this.showError(error.message);
                    this.updateStatus('è¼‰å…¥å¤±æ•—');
                    
                    // å˜—è©¦ä½¿ç”¨èˆŠçš„å¿«å–è³‡æ–™
                    const oldCache = this.getLocalCache();
                    if (oldCache) {
                        console.log('ä½¿ç”¨èˆŠå¿«å–è³‡æ–™');
                        this.processRouteData(oldCache.routes, true);
                        this.updateStatus('ä½¿ç”¨å¿«å–è³‡æ–™ (ç¶²è·¯é€£ç·šç•°å¸¸)');
                    }
                } finally {
                    this.showLoading(false);
                }
            }

            // è™•ç†è·¯ç·šè³‡æ–™
            processRouteData(routes, fromCache = false) {
                this.routeData = routes;
                this.clearRoutes();
                this.drawRoutes(routes);
                this.updateLegend(routes);
                this.updateLastUpdate(fromCache);
                this.updateRouteCount(routes.length);
            }

            // æ¸…é™¤ç¾æœ‰è·¯ç·š
            clearRoutes() {
                this.routeLayers.forEach(layer => {
                    this.map.removeLayer(layer);
                });
                this.routeLayers = [];
            }

            // ç¹ªè£½è·¯ç·š
            drawRoutes(routes) {
                routes.forEach((route, index) => {
                    const color = CONFIG.ROUTE_COLORS[index % CONFIG.ROUTE_COLORS.length];
                    this.drawSingleRoute(route, color, index);
                });

                // å¦‚æœæœ‰è·¯ç·šï¼Œèª¿æ•´åœ°åœ–è¦–é‡
                if (routes.length > 0) {
                    this.fitMapToRoutes();
                }
            }

            // ç¹ªè£½å–®ä¸€è·¯ç·š
            drawSingleRoute(route, color, index) {
                const points = this.getRouteCoordinates(route);
                
                if (points.length < 2) {
                    console.warn(`è·¯ç·š ${index + 1} åº§æ¨™ä¸è¶³:`, route);
                    return;
                }

                // ç¹ªè£½è·¯ç·š
                const polyline = L.polyline(points, {
                    color: color,
                    weight: 5,
                    opacity: 0.8,
                    dashArray: route.status === 'planned' ? '10, 5' : null
                }).addTo(this.map);

                // æ·»åŠ è·¯ç·šè³‡è¨Šå½ˆå‡ºè¦–çª—
                polyline.bindPopup(this.createRoutePopup(route), {
                    maxWidth: 300,
                    className: 'custom-popup'
                });

                // æ·»åŠ æ»‘é¼ æ‡¸åœæ•ˆæœ
                polyline.on('mouseover', function(e) {
                    this.setStyle({
                        weight: 7,
                        opacity: 1.0
                    });
                });

                polyline.on('mouseout', function(e) {
                    this.setStyle({
                        weight: 5,
                        opacity: 0.8
                    });
                });

                // æ·»åŠ èµ·é»å’Œçµ‚é»æ¨™è¨˜
                this.addRouteMarkers(points, route, color);
                
                this.routeLayers.push(polyline);
            }

            // å»ºç«‹è·¯ç·šå½ˆå‡ºè¦–çª—å…§å®¹
            createRoutePopup(route) {
                const middlePoints = [route.middle1, route.middle2]
                    .filter(point => point && point.trim() !== '')
                    .map((point, index) => `<p><strong>ğŸ“ ä¸­é»${index + 1}:</strong> ${point}</p>`)
                    .join('');

                return `
                    <div class="route-popup">
                        <h4>ğŸ“… ${route.date || 'æœªæŒ‡å®šæ—¥æœŸ'}</h4>
                        <p><strong>ğŸš© èµ·é»:</strong> ${route.start}</p>
                        ${middlePoints}
                        <p><strong>ğŸ çµ‚é»:</strong> ${route.end}</p>
                        <hr style="margin: 10px 0; border: 1px solid #eee;">
                        <small style="color: #666;">
                            è·é›¢: ${this.calculateRouteDistance(route)} å…¬é‡Œ<br>
                            é ä¼°æ™‚é–“: ${this.estimateRouteTime(route)} å°æ™‚
                        </small>
                    </div>
                `;
            }

            // ç²å–è·¯ç·šåº§æ¨™
            getRouteCoordinates(route) {
                const locations = [route.start, route.middle1, route.middle2, route.end]
                    .filter(loc => loc && loc.trim() !== '');
                
                const coordinates = locations
                    .map(location => {
                        const trimmedLocation = location.trim();
                        const coord = TAIWAN_LOCATIONS[trimmedLocation];
                        if (!coord) {
                            console.warn(`æ‰¾ä¸åˆ°åº§æ¨™: ${trimmedLocation}`);
                        }
                        return coord;
                    })
                    .filter(coord => coord !== undefined);

                return coordinates;
            }

            // æ·»åŠ è·¯ç·šæ¨™è¨˜
            addRouteMarkers(points, route, color) {
                if (points.length === 0) return;

                // èµ·é»æ¨™è¨˜
                const startMarker = L.marker(points[0], {
                    icon: this.createCustomIcon('ğŸš©', color, 'start')
                }).addTo(this.map);
                
                startMarker.bindPopup(`
                    <div style="text-align: center;">
                        <h4 style="color: ${color};">ğŸš© èµ·é»</h4>
                        <p><strong>${route.start}</strong></p>
                        <small>${route.date}</small>
                    </div>
                `);
                this.routeLayers.push(startMarker);

                // ä¸­é»æ¨™è¨˜
                if (points.length > 2) {
                    for (let i = 1; i < points.length - 1; i++) {
                        const middleMarker = L.marker(points[i], {
                            icon: this.createCustomIcon('ğŸ“', color, 'middle')
                        }).addTo(this.map);
                        
                        const middleLocation = i === 1 ? route.middle1 : route.middle2;
                        middleMarker.bindPopup(`
                            <div style="text-align: center;">
                                <h4 style="color: ${color};">ğŸ“ ä¸­é»${i}</h4>
                                <p><strong>${middleLocation}</strong></p>
                                <small>${route.date}</small>
                            </div>
                        `);
                        this.routeLayers.push(middleMarker);
                    }
                }

                // çµ‚é»æ¨™è¨˜
                if (points.length > 1) {
                    const endMarker = L.marker(points[points.length - 1], {
                        icon: this.createCustomIcon('ğŸ', color, 'end')
                    }).addTo(this.map);
                    
                    endMarker.bindPopup(`
                        <div style="text-align: center;">
                            <h4 style="color: ${color};">ğŸ çµ‚é»</h4>
                            <p><strong>${route.end}</strong></p>
                            <small>${route.date}</small>
                        </div>
                    `);
                    this.routeLayers.push(endMarker);
                }
            }

            // å»ºç«‹è‡ªå®šç¾©åœ–æ¨™
            createCustomIcon(emoji, color, type) {
                const size = type === 'middle' ? 25 : 35;
                const fontSize = type === 'middle' ? '12px' : '16px';
                
                return L.divIcon({
                    html: `
                        <div style="
                            background: ${color}; 
                            border-radius: 50%; 
                            width: ${size}px; 
                            height: ${size}px; 
                            display: flex; 
                            align-items: center; 
                            justify-content: center; 
                            border: 3px solid white; 
                            box-shadow: 0 3px 6px rgba(0,0,0,0.3);
                            font-size: ${fontSize};
                            animation: bounce 2s infinite;
                        ">${emoji}</div>
                        <style>
                            @keyframes bounce {
                                0%, 20%, 50%, 80%, 100% { transform: translateY(0); }
                                40% { transform: translateY(-10px); }
                                60% { transform: translateY(-5px); }
                            }
                        </style>
                    `,
                    className: 'custom-marker',
                    iconSize: [size, size],
                    iconAnchor: [size/2, size/2]
                });
            }

            // èª¿æ•´åœ°åœ–è¦–é‡ä»¥é¡¯ç¤ºæ‰€æœ‰è·¯ç·š
            fitMapToRoutes() {
                const allPoints = [];
                this.routeData.forEach(route => {
                    const points = this.getRouteCoordinates(route);
                    allPoints.push(...points);
                });

                if (allPoints.length > 0) {
                    const group = new L.featureGroup(
                        allPoints.map(point => L.marker(point))
                    );
                    this.map.fitBounds(group.getBounds().pad(0.1));
                }
            }

            // æ›´æ–°åœ–ä¾‹
            updateLegend(routes) {
                const legendContent = document.getElementById('legendContent');
                legendContent.innerHTML = '';

                if (routes.length === 0) {
                    legendContent.innerHTML = '<p style="color: #999; text-align: center;">æš«ç„¡è·¯ç·šè³‡æ–™</p>';
                    return;
                }

                routes.forEach((route, index) => {
                    const color = CONFIG.ROUTE_COLORS[index % CONFIG.ROUTE_COLORS.length];
                    const legendItem = document.createElement('div');
                    legendItem.className = 'legend-item';
                    
                    const routeText = `${route.date || 'æœªæŒ‡å®š'}: ${route.start} â†’ ${route.end}`;
                    const distance = this.calculateRouteDistance(route);
                    
                    legendItem.innerHTML = `
                        <div class="legend-color" style="background: ${color};"></div>
                        <div class="legend-text">
                            <div style="font-weight: bold;">${routeText}</div>
                            <div style="color: #888; font-size: 11px;">è·é›¢: ${distance} km</div>
                        </div>
                    `;
                    
                    // é»æ“Šåœ–ä¾‹é …ç›®æ™‚èšç„¦åˆ°å°æ‡‰è·¯ç·š
                    legendItem.addEventListener('click', () => {
                        this.focusOnRoute(route);
                    });
                    
                    legendContent.appendChild(legendItem);
                });
            }

            // èšç„¦åˆ°ç‰¹å®šè·¯ç·š
            focusOnRoute(route) {
                const points = this.getRouteCoordinates(route);
                if (points.length > 0) {
                    const group = new L.featureGroup(
                        points.map(point => L.marker(point))
                    );
                    this.map.fitBounds(group.getBounds().pad(0.2));
                }
            }

            // è¨ˆç®—è·¯ç·šè·é›¢ (ç°¡åŒ–ç‰ˆæœ¬)
            calculateRouteDistance(route) {
                const points = this.getRouteCoordinates(route);
                if (points.length < 2) return 0;

                let totalDistance = 0;
                for (let i = 0; i < points.length - 1; i++) {
                    totalDistance += this.calculateDistance(points[i], points[i + 1]);
                }
                return Math.round(totalDistance);
            }

            // è¨ˆç®—å…©é»é–“è·é›¢ (å“ˆå¼—è¾›å…¬å¼)
            calculateDistance(point1, point2) {
                const R = 6371; // åœ°çƒåŠå¾‘ (å…¬é‡Œ)
                const dLat = this.toRadians(point2[0] - point1[0]);
                const dLon = this.toRadians(point2[1] - point1[1]);
                const lat1 = this.toRadians(point1[0]);
                const lat2 = this.toRadians(point2[0]);

                const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                         Math.sin(dLon/2) * Math.sin(dLon/2) * Math.cos(lat1) * Math.cos(lat2);
                const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
                
                return R * c;
            }
            // è§’åº¦è½‰å¼§åº¦
            toRadians(degrees) {
                return degrees * (Math.PI / 180);
            }

            // ä¼°ç®—è·¯ç·šæ™‚é–“
            estimateRouteTime(route) {
                const distance = this.calculateRouteDistance(route);
                const avgSpeed = 60; // å¹³å‡é€Ÿåº¦ 60 km/h
                return Math.round((distance / avgSpeed) * 10) / 10;
            }

            // æœ¬åœ°å¿«å–ç®¡ç†
            saveLocalCache(routes) {
                try {
                    const cacheData = {
                        routes: routes,
                        timestamp: Date.now()
                    };
                    localStorage.setItem('taiwanRouteCache', JSON.stringify(cacheData));
                } catch (error) {
                    console.warn('ç„¡æ³•å„²å­˜å¿«å–:', error);
                }
            }

            getLocalCache() {
                try {
                    const cached = localStorage.getItem('taiwanRouteCache');
                    return cached ? JSON.parse(cached) : null;
                } catch (error) {
                    console.warn('ç„¡æ³•è®€å–å¿«å–:', error);
                    return null;
                }
            }

            clearLocalCache() {
                try {
                    localStorage.removeItem('taiwanRouteCache');
                    this.updateStatus('å¿«å–å·²æ¸…é™¤');
                    alert('âœ… æœ¬åœ°å¿«å–å·²æ¸…é™¤ï¼ä¸‹æ¬¡è¼‰å…¥å°‡ç²å–æœ€æ–°è³‡æ–™ã€‚');
                } catch (error) {
                    console.warn('ç„¡æ³•æ¸…é™¤å¿«å–:', error);
                }
            }

            isCacheValid(timestamp) {
                const cacheAge = Date.now() - timestamp;
                const maxAge = 10 * 60 * 1000; // 10åˆ†é˜
                return cacheAge < maxAge;
            }

            // UI æ›´æ–°æ–¹æ³•
            showLoading(show) {
                const loading = document.getElementById('loading');
                if (show) {
                    loading.classList.remove('hidden');
                } else {
                    loading.classList.add('hidden');
                }
            }

            showError(message = 'è¼‰å…¥å¤±æ•—ï¼Œè«‹ç¨å¾Œå†è©¦') {
                const errorDiv = document.getElementById('error');
                const errorMessage = document.getElementById('errorMessage');
                errorMessage.textContent = message;
                errorDiv.classList.remove('hidden');
            }

            hideError() {
                document.getElementById('error').classList.add('hidden');
            }

            updateStatus(status) {
                document.getElementById('statusText').textContent = status;
            }

            updateLastUpdate(fromCache = false) {
                const now = new Date();
                const timeString = now.toLocaleString('zh-TW', {
                    year: 'numeric',
                    month: '2-digit',
                    day: '2-digit',
                    hour: '2-digit',
                    minute: '2-digit',
                    second: '2-digit'
                });
                
                const cacheIndicator = fromCache ? ' (å¿«å–)' : '';
                document.getElementById('lastUpdate').textContent = timeString + cacheIndicator;
            }

            updateRouteCount(count) {
                document.getElementById('routeCount').textContent = count;
            }

            // è‡ªå‹•æ›´æ–°
            startAutoRefresh() {
                // æ¸…é™¤ç¾æœ‰è¨ˆæ™‚å™¨
                if (this.autoRefreshTimer) {
                    clearInterval(this.autoRefreshTimer);
                }

                // è¨­å®šæ–°çš„è‡ªå‹•æ›´æ–°è¨ˆæ™‚å™¨
                this.autoRefreshTimer = setInterval(() => {
                    console.log('è‡ªå‹•æ›´æ–°è·¯ç·šè³‡æ–™...');
                    this.loadRoutes();
                }, CONFIG.REFRESH_INTERVAL);

                console.log(`å·²å•Ÿå‹•è‡ªå‹•æ›´æ–°ï¼Œé–“éš”: ${CONFIG.REFRESH_INTERVAL / 1000} ç§’`);
            }

            stopAutoRefresh() {
                if (this.autoRefreshTimer) {
                    clearInterval(this.autoRefreshTimer);
                    this.autoRefreshTimer = null;
                    console.log('å·²åœæ­¢è‡ªå‹•æ›´æ–°');
                }
            }

            // åŒ¯å‡ºè³‡æ–™åŠŸèƒ½
            exportRouteData() {
                try {
                    const dataStr = JSON.stringify(this.routeData, null, 2);
                    const dataBlob = new Blob([dataStr], {type: 'application/json'});
                    
                    const link = document.createElement('a');
                    link.href = URL.createObjectURL(dataBlob);
                    link.download = `taiwan_routes_${new Date().toISOString().split('T')[0]}.json`;
                    link.click();
                    
                    this.updateStatus('è³‡æ–™åŒ¯å‡ºæˆåŠŸ');
                } catch (error) {
                    console.error('åŒ¯å‡ºå¤±æ•—:', error);
                    alert('âŒ åŒ¯å‡ºå¤±æ•—ï¼Œè«‹ç¨å¾Œå†è©¦');
                }
            }

            // æœå°‹åŠŸèƒ½
            searchRoutes(keyword) {
                const filteredRoutes = this.routeData.filter(route => {
                    return route.start.includes(keyword) || 
                           route.end.includes(keyword) ||
                           (route.middle1 && route.middle1.includes(keyword)) ||
                           (route.middle2 && route.middle2.includes(keyword)) ||
                           (route.date && route.date.includes(keyword));
                });

                this.clearRoutes();
                this.drawRoutes(filteredRoutes);
                this.updateLegend(filteredRoutes);
                this.updateRouteCount(filteredRoutes.length);
                
                if (filteredRoutes.length === 0) {
                    alert(`ğŸ” æ‰¾ä¸åˆ°åŒ…å« "${keyword}" çš„è·¯ç·š`);
                } else {
                    this.updateStatus(`æœå°‹çµæœ: ${filteredRoutes.length} æ¢è·¯ç·š`);
                }
            }

            // é‡ç½®é¡¯ç¤º
            resetDisplay() {
                this.clearRoutes();
                this.drawRoutes(this.routeData);
                this.updateLegend(this.routeData);
                this.updateRouteCount(this.routeData.length);
                this.updateStatus('å·²é‡ç½®é¡¯ç¤º');
            }

            // ç²å–çµ±è¨ˆè³‡è¨Š
            getStatistics() {
                const stats = {
                    totalRoutes: this.routeData.length,
                    totalDistance: 0,
                    totalTime: 0,
                    cities: new Set(),
                    dateRange: {
                        earliest: null,
                        latest: null
                    }
                };

                this.routeData.forEach(route => {
                    // è¨ˆç®—ç¸½è·é›¢å’Œæ™‚é–“
                    const distance = this.calculateRouteDistance(route);
                    const time = this.estimateRouteTime(route);
                    stats.totalDistance += distance;
                    stats.totalTime += time;

                    // æ”¶é›†åŸå¸‚
                    [route.start, route.middle1, route.middle2, route.end]
                        .filter(city => city && city.trim() !== '')
                        .forEach(city => stats.cities.add(city.trim()));

                    // æ—¥æœŸç¯„åœ
                    if (route.date) {
                        const date = new Date(route.date);
                        if (!stats.dateRange.earliest || date < stats.dateRange.earliest) {
                            stats.dateRange.earliest = date;
                        }
                        if (!stats.dateRange.latest || date > stats.dateRange.latest) {
                            stats.dateRange.latest = date;
                        }
                    }
                });

                stats.cities = Array.from(stats.cities);
                stats.totalDistance = Math.round(stats.totalDistance);
                stats.totalTime = Math.round(stats.totalTime * 10) / 10;

                return stats;
            }

            // é¡¯ç¤ºçµ±è¨ˆè³‡è¨Š
            showStatistics() {
                const stats = this.getStatistics();
                const earliestDate = stats.dateRange.earliest ? 
                    stats.dateRange.earliest.toLocaleDateString('zh-TW') : 'ç„¡';
                const latestDate = stats.dateRange.latest ? 
                    stats.dateRange.latest.toLocaleDateString('zh-TW') : 'ç„¡';

                const statsHtml = `
                    <div style="font-family: Microsoft JhengHei; line-height: 1.6;">
                        <h3 style="color: #4CAF50; margin-bottom: 15px;">ğŸ“Š è·¯ç·šçµ±è¨ˆè³‡è¨Š</h3>
                        <p><strong>ğŸ“ˆ ç¸½è·¯ç·šæ•¸:</strong> ${stats.totalRoutes} æ¢</p>
                        <p><strong>ğŸ“ ç¸½è·é›¢:</strong> ${stats.totalDistance} å…¬é‡Œ</p>
                        <p><strong>â±ï¸ ç¸½æ™‚é–“:</strong> ${stats.totalTime} å°æ™‚</p>
                        <p><strong>ğŸ™ï¸ æ¶‰åŠåŸå¸‚:</strong> ${stats.cities.length} å€‹</p>
                        <p><strong>ğŸ“… æ—¥æœŸç¯„åœ:</strong> ${earliestDate} ~ ${latestDate}</p>
                        <hr style="margin: 15px 0;">
                        <p><strong>ğŸŒŸ å¹³å‡æ¯æ¢è·¯ç·š:</strong></p>
                        <p style="margin-left: 20px;">
                            è·é›¢: ${Math.round(stats.totalDistance / stats.totalRoutes)} å…¬é‡Œ<br>
                            æ™‚é–“: ${Math.round((stats.totalTime / stats.totalRoutes) * 10) / 10} å°æ™‚
                        </p>
                        <p><strong>ğŸ—ºï¸ ä¸»è¦åŸå¸‚:</strong></p>
                        <p style="margin-left: 20px; font-size: 0.9em;">
                            ${stats.cities.slice(0, 10).join(', ')}
                            ${stats.cities.length > 10 ? '...' : ''}
                        </p>
                    </div>
                `;

                // å»ºç«‹çµ±è¨ˆå½ˆå‡ºè¦–çª—
                const popup = L.popup({
                    maxWidth: 400,
                    className: 'stats-popup'
                })
                .setLatLng(CONFIG.MAP_CENTER)
                .setContent(statsHtml)
                .openOn(this.map);
            }

            // éŠ·æ¯€æ–¹æ³•
            destroy() {
                this.stopAutoRefresh();
                this.clearRoutes();
                if (this.map) {
                    this.map.remove();
                }
            }
        }

        // å…¨åŸŸè®Šæ•¸
        let taiwanMap;

        // é é¢è¼‰å…¥å®Œæˆå¾Œåˆå§‹åŒ–
        document.addEventListener('DOMContentLoaded', () => {
            console.log('ğŸš€ å°ç£è·¯ç·šåœ°åœ–ç³»çµ±å•Ÿå‹•ä¸­...');
            
            try {
                taiwanMap = new TaiwanRouteMap();
                window.taiwanMap = taiwanMap; // ä¾›å¤–éƒ¨è¨ªå•
                
                // æ·»åŠ éµç›¤å¿«æ·éµ
                document.addEventListener('keydown', (e) => {
                    if (e.ctrlKey || e.metaKey) {
                        switch(e.key) {
                            case 'r':
                                e.preventDefault();
                                taiwanMap.loadRoutes();
                                break;
                            case 'l':
                                e.preventDefault();
                                document.getElementById('toggleLegend').click();
                                break;
                            case 's':
                                e.preventDefault();
                                taiwanMap.showStatistics();
                                break;
                            case 'e':
                                e.preventDefault();
                                taiwanMap.exportRouteData();
                                break;
                        }
                    }
                });

                // æ·»åŠ æœå°‹åŠŸèƒ½
                const searchInput = document.createElement('input');
                searchInput.type = 'text';
                searchInput.placeholder = 'ğŸ” æœå°‹è·¯ç·š... (Ctrl+F)';
                searchInput.style.cssText = `
                    position: absolute;
                    top: 20px;
                    left: 20px;
                    z-index: 1000;
                    padding: 10px 15px;
                    border: none;
                    border-radius: 25px;
                    background: rgba(255, 255, 255, 0.9);
                    backdrop-filter: blur(10px);
                    box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
                    font-size: 14px;
                    width: 200px;
                    transition: all 0.3s ease;
                `;

                searchInput.addEventListener('focus', () => {
                    searchInput.style.width = '250px';
                    searchInput.style.background = 'rgba(255, 255, 255, 0.95)';
                });

                searchInput.addEventListener('blur', () => {
                    searchInput.style.width = '200px';
                    searchInput.style.background = 'rgba(255, 255, 255, 0.9)';
                });

                searchInput.addEventListener('input', (e) => {
                    const keyword = e.target.value.trim();
                    if (keyword === '') {
                        taiwanMap.resetDisplay();
                    } else if (keyword.length >= 2) {
                        taiwanMap.searchRoutes(keyword);
                    }
                });

                // æ·»åŠ  Ctrl+F å¿«æ·éµèšç„¦æœå°‹æ¡†
                document.addEventListener('keydown', (e) => {
                    if ((e.ctrlKey || e.metaKey) && e.key === 'f') {
                        e.preventDefault();
                        searchInput.focus();
                    }
                });

                document.querySelector('.map-container').appendChild(searchInput);

                // æ·»åŠ çµ±è¨ˆæŒ‰éˆ•
                const statsBtn = document.createElement('button');
                statsBtn.innerHTML = 'ğŸ“Š çµ±è¨ˆ';
                statsBtn.onclick = () => taiwanMap.showStatistics();
                document.querySelector('.controls').appendChild(statsBtn);

                // æ·»åŠ åŒ¯å‡ºæŒ‰éˆ•
                const exportBtn = document.createElement('button');
                exportBtn.innerHTML = 'ğŸ’¾ åŒ¯å‡º';
                exportBtn.onclick = () => taiwanMap.exportRouteData();
                document.querySelector('.controls').appendChild(exportBtn);

                console.log('âœ… ç³»çµ±åˆå§‹åŒ–å®Œæˆï¼');
                console.log('ğŸ”§ å¿«æ·éµèªªæ˜:');
                console.log('   Ctrl+R: é‡æ–°è¼‰å…¥');
                console.log('   Ctrl+L: åˆ‡æ›åœ–ä¾‹');
                console.log('   Ctrl+S: é¡¯ç¤ºçµ±è¨ˆ');
                console.log('   Ctrl+E: åŒ¯å‡ºè³‡æ–™');
                console.log('   Ctrl+F: æœå°‹è·¯ç·š');

            } catch (error) {
                console.error('âŒ ç³»çµ±åˆå§‹åŒ–å¤±æ•—:', error);
                alert('ç³»çµ±åˆå§‹åŒ–å¤±æ•—ï¼Œè«‹é‡æ–°æ•´ç†é é¢');
            }
        });

        // é é¢å¸è¼‰æ™‚æ¸…ç†è³‡æº
        window.addEventListener('beforeunload', () => {
            if (taiwanMap) {
                taiwanMap.destroy();
            }
        });

        // è™•ç†ç¶²è·¯ç‹€æ…‹è®ŠåŒ–
        window.addEventListener('online', () => {
            console.log('ğŸŒ ç¶²è·¯é€£ç·šæ¢å¾©');
            if (taiwanMap) {
                taiwanMap.updateStatus('ç¶²è·¯é€£ç·šæ¢å¾©');
                taiwanMap.loadRoutes();
            }
        });

        window.addEventListener('offline', () => {
            console.log('ğŸ“¡ ç¶²è·¯é€£ç·šä¸­æ–·');
            if (taiwanMap) {
                taiwanMap.updateStatus('ç¶²è·¯é€£ç·šä¸­æ–· (ä½¿ç”¨å¿«å–è³‡æ–™)');
            }
        });

        // è¦–çª—å¤§å°è®ŠåŒ–æ™‚èª¿æ•´åœ°åœ–
        window.addEventListener('resize', () => {
            if (taiwanMap && taiwanMap.map) {
                setTimeout(() => {
                    taiwanMap.map.invalidateSize();
                }, 100);
            }
        });

        // éŒ¯èª¤è™•ç†
        window.addEventListener('error', (e) => {
            console.error('å…¨åŸŸéŒ¯èª¤:', e.error);
            if (taiwanMap) {
                taiwanMap.updateStatus('ç³»çµ±ç™¼ç”ŸéŒ¯èª¤');
            }
        });

        // æœªè™•ç†çš„ Promise æ‹’çµ•
        window.addEventListener('unhandledrejection', (e) => {
            console.error('æœªè™•ç†çš„ Promise éŒ¯èª¤:', e.reason);
            e.preventDefault();
        });

        // é–‹ç™¼è€…å·¥å…·
        if (window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1') {
            console.log('ğŸ”§ é–‹ç™¼æ¨¡å¼å·²å•Ÿç”¨');
            window.debugTaiwanMap = {
                getRouteData: () => taiwanMap?.routeData,
                getStatistics: () => taiwanMap?.getStatistics(),
                clearCache: () => taiwanMap?.clearLocalCache(),
                exportData: () => taiwanMap?.exportRouteData(),
                loadRoutes: () => taiwanMap?.loadRoutes()
            };
        }
    </script>
</body>
</html>
